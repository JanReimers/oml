Disconnect HEAD in git
    Just do this:

    git checkout master
    Or, if you have changes that you want to keep, do this:

    git checkout -b temp
    git checkout -B master temp
Ranges:
    Based on https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/ 
    maybe we can do lazy evaluation with ranges/views
    Yes: -Use std::valarray, std::vector or oml::cow_array interchangably?
    Done: Ranges/views: 
        Done: -A full matrix row is just a chunk view of the data array.
        Done: -A full matrix column is a strided view
        Done: - M*V, V*M, M*M are all views
            for M*M we need create range of rows and a range of columns.  Which one gets used depends on the next operator
            operation.   so for A*B*C=(A*B)*C=AB*C we need to use the range of column for AB and the range of rows does not get used.
            Do we take a performance for the unused ranges?  Hopefully just a minor O(1) hit that would be hard ot measure.
        -This raises the point that we should make (eager) BLAS versions for comparison.
        Done: -As before we finalize a chain of views with assign_from(V&& view);
        Done: -TO support various packings the VectorView returned by M.col(1) should only hold a range over the non-zero indices.
            It also needs to know what those indices are.  this is an iota_view range.
            Done: Now how to do the innder product of two VectorViews while taking into the account indices.
        Done: -Right now we have 4 version of the vector dot product: view*view view*vec vec*view vec*vec
            view*view does the actuall work the rest just call view*vec.view();
            this would go away of vec was derived from view.  But that would required passing data, before data is constructed.
            Fixed with concepts.

    -Ideally we support full, symmetric (hermitian) , diagonal, triangular (upper and lower), banded, tridiangonl matrix packing.
        Use subscriptor classes to handle all the packing, total size and indexing.
        Done: These can return views over the rows.
            Getting views over columns is much more difficult for anything but a full matrix.
            use trnasform()
                auto col[j,this](size_t i){return operator()(i,j)}
                return data | transform(col)
        Use indexing formulas defined in the Lapack docs. ?
        Symmetric is the only packing that must be square?
        Somehow take a fill value/method in the constructors
            
        Still do 1 based like fortran?  Optional?
            Do this last with MatLimitd and VecLimits.
    template <typename T, class Data<T>, packing P, symmetry S> class Matrix{};
        enum class packing {full, upper_tri, lower_tri, diagonal, banded (Nb), tridiangonl}; 
        enum class symmetry {none, symmetric};
    Distinguish row and column vectors?
        Then RowVector = Matrix(1,N), ColVector = Matrix(N,1)
        Then we end up wasting time working with Matrix(1,1) = scaler. 
    OML2
        Create empty repo
        Load in range/concepts based Vector, VectorView, Matrix, Subscriptors, MatrixProductView
        -decide on namespace and naming conventions
            CamelBack or underscore_delimited?
                
        -TransposeView, DiagonalView
        -Use print statments in op(i,j) to make sure evaluations really are lazy.
        -Make eager BLAS version of M*m
        -op+ op- op+= op-= M*s, M/s, s*M M*=s M/=s
        -init options
            enums: zero, one, random, linear, power, value, unit?  The last four are parameterized.  zero = value,0.0
        -Get banded subscriptor working,  tri is banded with
        -How to handle symmetric?  Use triangular subscriptor
        -Get subscriptors hamronized with lapack/blas.
        -deduce the correct subscrptor for a matrix product.
            tridiagonal*tridiagonal = banded<k=2>
            uppertri*uppertri = uppertri
            uppertri*lowertri = full
            diagonal*X = X*diagonal = X
            full * X = X * full = full.
        -handle complex.
        -handle Matrix<Matrix<T>>
            



Work list:
    Lapack and oml symmetric storage is backwards.  Should make oml consistent with Lapack.
        See https://netlib.org/lapack//explore-html/d0/de3/group__pptri_ga7429f5db00250f8e8dc56cd787f9cf8f.html#ga7429f5db00250f8e8dc56cd787f9cf8f
            for definition of SymOffsets:
            if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
            if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
    Unit tests showing size miss-matches in BinaryFunction1
    Done: A*B return Matrix instead of proxy.  Then A*B*C*D*E*F will work efficiently.
    Symmetric A*B return Matrix instead of proxy.  Then A*B*C*D*E*F will work efficiently.
    Bug: A+B where A if diagonal matrix, and B is full matrix
        In this case we can't use array add.
    Done: Bug: for (index_t i:m.cols(i+1)) is broken if GetNumCols()==0
    Done: Organize header include order for indexable, and matalg headers
        Done: Move chunks of matalg into Matrix and Diag matrix headers.
    Done: Default constructors should create zero size Vectors and Matrices.
    Done: Git rid of Matrix
    Done: Rename DMatrix to Matrix
    Done: Fix up unit tests for double (forget int float for now)
        Done: Vector
        Done Matrix
            Done Need more mix types
        Done DiagonalMatrix
        Done SymmetricMatrix
        SparseMatrix
    Move SparseMatrix into OML
    Round out LAPack and Arpack wrappers and move everything to oml
    Done: Is it possible to simplify expression templates with C++17? (yes!)
    Done Beef up Diagonal matrices.
    Done: add fabs for complex matrices and stop using abs
    Done: use int_64 throughout
    F(A-B) for work where F(const Matrix<T>&)
    Initialize value as third argument, Loose to FIll routines
        This has consequences
            1) Vector<dcmplx>(10,0.5) -> uses the Vector(int low,int high) constructor
            2) Vector<Matrix<whatever>> breaks to compile on the Fill calls.
                We can solve by keeping everything inline & dont use FillType=None
    Does explicit on the contructors help with anything?
    use class enums
    Use constructor delegation
        Done: Vector
        Matrix
        DiagonalMatrix
        SymmetricMatrix
    Create vector T*, set num owners=2
        Not possible with std::vector instead of cow_array
    Failed idea:  I was hoping that Rvalue Ref-qualified overloaded operator like
        operator()(int i, int j) && and could get picked when a non-const matrix is being used as
        an R-value like
            Matrix<double> A(5,5);
            double a12=A(1,2); //should pick out operator()(int i, int j) && instead of operator()(int i, int j) &
        but g++ at least is not cooperating, it always picks up the lvalue version operator()()&
        Maybe its worth posting a minimal sample on stack exchange.
